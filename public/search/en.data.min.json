[{"id":0,"href":"/movingfeaturesformats/","title":"Moving Feature Formats","parent":"MEOS","content":"Temporal types can be represented in the following formats:\nWell-Known Text (WKT) Well-Known Binary (WKB) Moving-Features JSON (MF-JSON) "},{"id":1,"href":"/tutorialprograms/","title":"Tutorial Programs","parent":"MEOS","content":"Tutorial programs exploring the functionality provided by the MEOS library\nMy First MEOS Program Read from File Assemble Trips Store in MobilityDB Disassemble Trips Clip Trips to Geometries Tile Trips Simplify Trips Aggregate Trips Similar programs in Python using PyMEOS can be found here.\n"},{"id":2,"href":"/movingfeaturesformats/mfjson/","title":"Moving Features JSON (MF-JSON)","parent":"Moving Feature Formats","content":"“Moving Features JSON” is a standard for encoding moving features in JSON. By using MF-JSON, rather than some other arbitrary scheme, you maximize the interoperability of your JSON output. MF-JSON is an Open Geospatial Consortium standard, which extends the GeoJSON standard.\nExamples {\u0026ldquo;type\u0026rdquo;:\u0026ldquo;MovingBoolean\u0026rdquo;,\u0026ldquo;values\u0026rdquo;:true,\u0026ldquo;datetimes\u0026rdquo;:\u0026ldquo;2000-01-01T00:00:00\u0026rdquo;,\u0026ldquo;interpolations\u0026rdquo;:[\u0026ldquo;Discrete\u0026rdquo;]} {\u0026ldquo;type\u0026rdquo;:\u0026ldquo;MovingInteger\u0026rdquo;,\u0026ldquo;values\u0026rdquo;:2,\u0026ldquo;datetimes\u0026rdquo;:\u0026ldquo;2000-01-01T00:00:00\u0026rdquo;,\u0026ldquo;interpolations\u0026rdquo;:[\u0026ldquo;Discrete\u0026rdquo;]} {\u0026ldquo;type\u0026rdquo;:\u0026ldquo;MovingFloat\u0026rdquo;,\u0026ldquo;values\u0026rdquo;:2.5,\u0026ldquo;datetimes\u0026rdquo;:\u0026ldquo;2000-01-01T00:00:00\u0026rdquo;,\u0026ldquo;interpolations\u0026rdquo;:[\u0026ldquo;Discrete\u0026rdquo;]} {\u0026ldquo;type\u0026rdquo;:\u0026ldquo;MovingText\u0026rdquo;,\u0026ldquo;values\u0026rdquo;:\u0026ldquo;walking\u0026rdquo;,\u0026ldquo;datetimes\u0026rdquo;:\u0026ldquo;2000-01-01T00:00:00\u0026rdquo;,\u0026ldquo;interpolations\u0026rdquo;:[\u0026ldquo;Discrete\u0026rdquo;]} {\u0026ldquo;type\u0026rdquo;:\u0026ldquo;MovingPoint\u0026rdquo;,\u0026ldquo;coordinates\u0026rdquo;:[1,1],\u0026ldquo;datetimes\u0026rdquo;:\u0026ldquo;2000-01-01T00:00:00\u0026rdquo;,\u0026ldquo;interpolations\u0026rdquo;:[\u0026ldquo;Discrete\u0026rdquo;]} {\u0026ldquo;type\u0026rdquo;:\u0026ldquo;MovingPoint\u0026rdquo;,\u0026ldquo;crs\u0026rdquo;:{\u0026ldquo;type\u0026rdquo;:\u0026ldquo;name\u0026rdquo;,\u0026ldquo;properties\u0026rdquo;:{\u0026ldquo;name\u0026rdquo;:\u0026ldquo;EPSG:5676\u0026rdquo;}},\u0026ldquo;coordinates\u0026rdquo;:[1,1],\u0026ldquo;datetimes\u0026rdquo;:\u0026ldquo;2000-01-01T00:00:00\u0026rdquo;,\u0026ldquo;interpolations\u0026rdquo;:[\u0026ldquo;Discrete\u0026rdquo;]} {\u0026ldquo;type\u0026rdquo;:\u0026ldquo;MovingInteger\u0026rdquo;,\u0026ldquo;values\u0026rdquo;:[1,2],\u0026ldquo;datetimes\u0026rdquo;:[\u0026ldquo;2022-01-01T08:00:00\u0026rdquo;,\u0026ldquo;2022-01-01T09:00:00\u0026rdquo;],\u0026ldquo;interpolations\u0026rdquo;:[\u0026ldquo;Discrete\u0026rdquo;]} {\u0026ldquo;type\u0026rdquo;:\u0026ldquo;MovingPoint\u0026rdquo;,\u0026ldquo;coordinates\u0026rdquo;:[[1,1],[2,2]],\u0026ldquo;datetimes\u0026rdquo;:[\u0026ldquo;2022-01-01T08:00:00\u0026rdquo;,\u0026ldquo;2022-01-01T09:00:00\u0026rdquo;],\u0026ldquo;lower_inc\u0026rdquo;:true,\u0026ldquo;upper_inc\u0026rdquo;:true,\u0026ldquo;interpolations\u0026rdquo;:[\u0026ldquo;Linear\u0026rdquo;]} {\u0026ldquo;type\u0026rdquo;:\u0026ldquo;MovingText\u0026rdquo;,\u0026ldquo;sequences\u0026rdquo;:[{\u0026ldquo;values\u0026rdquo;:[\u0026ldquo;driving\u0026rdquo;,\u0026ldquo;driving\u0026rdquo;],\u0026ldquo;datetimes\u0026rdquo;:[\u0026ldquo;2022-01-01T08:00:00\u0026rdquo;,\u0026ldquo;2022-01-01T09:00:00\u0026rdquo;],\u0026ldquo;lower_inc\u0026rdquo;:true,\u0026ldquo;upper_inc\u0026rdquo;:true},{\u0026ldquo;values\u0026rdquo;:[\u0026ldquo;walking\u0026rdquo;,\u0026ldquo;walking\u0026rdquo;],\u0026ldquo;datetimes\u0026rdquo;:[\u0026ldquo;2022-01-01T10:00:00\u0026rdquo;,\u0026ldquo;2022-01-01T11:00:00\u0026rdquo;],\u0026ldquo;lower_inc\u0026rdquo;:true,\u0026ldquo;upper_inc\u0026rdquo;:true}],\u0026ldquo;interpolations\u0026rdquo;:[\u0026ldquo;Stepwise\u0026rdquo;]} {\u0026ldquo;type\u0026rdquo;:\u0026ldquo;MovingPoint\u0026rdquo;,\u0026ldquo;sequences\u0026rdquo;:[{\u0026ldquo;coordinates\u0026rdquo;:[[1,1],[2,2]],\u0026ldquo;datetimes\u0026rdquo;:[\u0026ldquo;2022-01-01T08:00:00\u0026rdquo;,\u0026ldquo;2022-01-01T09:00:00\u0026rdquo;],\u0026ldquo;lower_inc\u0026rdquo;:true,\u0026ldquo;upper_inc\u0026rdquo;:true},{\u0026ldquo;coordinates\u0026rdquo;:[[3,3],[3,3]],\u0026ldquo;datetimes\u0026rdquo;:[\u0026ldquo;2022-01-01T10:00:00\u0026rdquo;,\u0026ldquo;2022-01-01T11:00:00\u0026rdquo;],\u0026ldquo;lower_inc\u0026rdquo;:true,\u0026ldquo;upper_inc\u0026rdquo;:true}],\u0026ldquo;interpolations\u0026rdquo;:[\u0026ldquo;Linear\u0026rdquo;]} "},{"id":3,"href":"/movingfeaturesformats/wkb/","title":"Well-Known Binary (WKB)","parent":"Moving Feature Formats","content":"“Well-known binary” is a scheme for writing moving features into a platform-independent array of bytes, usually for transport between systems or between programs. By using WKB, systems can avoid exposing their particular internal implementation of moving feature storage, for greater overall interoperability. It is an extension of the scheme for writing a simple features geometry into a platform-independent array of bytes.\nData Types The WKB specification uses five basic types common to most typed languages: an unsigned byte, a 4-byte unsigned integer, an 8-byte unsigned integer, an 8-byte IEEE double, and a string of characters.\n// byte : 1 byte // uint32 : 32 bit unsigned integer (4 bytes) // uint64 : 64 bit unsigned integer (8 bytes) // double : double precision number (8 bytes) // string : string of characters (variable number of bytes) Byte Order In order to allow portability between systems with difference architectures, the representation of those types is conditioned by the wkbByteOrder.\nenum wkbByteOrder { wkbXDR = 0, // Big Endian wkbNDR = 1 // Little Endian }; A “little endian” integer has the least-significant bytes first, hence “little”. For example, the number 1, encoded in little- and big- endian:\n# Little endian 01 00 00 00 # Big endian 00 00 00 01 In practice this means that almost all WKB is encoded little endian, since most modern processors are little endian, but the existence of the wkbByteOrder allows WKB to transport geometry easily between systems of different endianness.\n"},{"id":4,"href":"/movingfeaturesformats/wkt/","title":"Well-Known Text (WKT)","parent":"Moving Feature Formats","content":"“Well-known text” is a scheme for writing moving features into a standard text string. It is an extension of the scheme for writing a simple features geometry into a standard text string.\nWKT BNF For ease of presentation we suppose the following standard types: \u0026lt;integer\u0026gt;, \u0026lt;float\u0026gt;, \u0026lt;string\u0026gt;, and \u0026lt;timestamp with timezone\u0026gt;;\nSpan types \u0026lt;comma\u0026gt; ::= \u0026#39;,\u0026#39; \u0026lt;left paren\u0026gt; ::= \u0026#39;(\u0026#39; \u0026lt;right paren\u0026gt; ::= \u0026#39;)\u0026#39; \u0026lt;left bracket\u0026gt; ::= \u0026#39;[\u0026#39; \u0026lt;right bracket\u0026gt; ::= \u0026#39;]\u0026#39; \u0026lt;left brace\u0026gt; ::= \u0026#39;{\u0026#39; \u0026lt;right brace\u0026gt; ::= \u0026#39;}\u0026#39; \u0026lt;left bound\u0026gt; := \u0026lt;left bracket\u0026gt; | \u0026lt;left paren\u0026gt; \u0026lt;right bound\u0026gt; := \u0026lt;right bracket\u0026gt; | \u0026lt;right paren\u0026gt; \u0026lt;int span wkt\u0026gt; ::= \u0026lt;left bound\u0026gt; \u0026lt;integer\u0026gt; \u0026lt;comma\u0026gt; \u0026lt;integer\u0026gt; \u0026lt;right bound\u0026gt; \u0026lt;float span wkt\u0026gt; ::= \u0026lt;left bound\u0026gt; \u0026lt;float\u0026gt; \u0026lt;comma\u0026gt; \u0026lt;float\u0026gt; \u0026lt;right bound\u0026gt; \u0026lt;period wkt\u0026gt; ::= \u0026lt;left bound\u0026gt; \u0026lt;timestamp with timezone\u0026gt; \u0026lt;comma\u0026gt; \u0026lt;timestamp with timezone\u0026gt; \u0026lt;right bound\u0026gt; \u0026lt;span wkt\u0026gt; ::= \u0026lt;int span wkt\u0026gt; | \u0026lt;float span wkt\u0026gt; | \u0026lt;period wkt\u0026gt; Time set types \u0026lt;timestamp set wkt\u0026gt; ::= \u0026lt;left brace\u0026gt; \u0026lt;timestamp with timezone\u0026gt; {\u0026lt;comma\u0026gt; \u0026lt;timestamp with timezone\u0026gt;} ... \u0026lt;right brace\u0026gt; \u0026lt;period set wkt\u0026gt; ::= \u0026lt;left brace\u0026gt; \u0026lt;period wkt\u0026gt; {\u0026lt;comma\u0026gt; \u0026lt;period wkt\u0026gt;} ... \u0026lt;right brace\u0026gt; \u0026lt;time set wkt\u0026gt; ::= \u0026lt;timestamp set wkt\u0026gt; | \u0026lt;period set wkt\u0026gt; Box types \u0026lt;x\u0026gt; := \u0026#39;X\u0026#39; \u0026lt;t\u0026gt; := \u0026#39;T\u0026#39; \u0026lt;xt\u0026gt; := \u0026#39;XT\u0026#39; \u0026lt;tbox\u0026gt; ::= \u0026#39;TBOX\u0026#39; \u0026lt;tbox xt\u0026gt; ::= \u0026lt;tbox\u0026gt; \u0026lt;xt\u0026gt; \u0026lt;left paren\u0026gt; \u0026lt;float span\u0026gt; \u0026lt;comma\u0026gt; \u0026lt;period\u0026gt; \u0026lt;right paren\u0026gt; \u0026lt;tbox x\u0026gt; ::= \u0026lt;tbox\u0026gt; \u0026lt;x\u0026gt; \u0026lt;left paren\u0026gt; \u0026lt;float span\u0026gt; \u0026lt;right paren\u0026gt; \u0026lt;tbox t\u0026gt; ::= \u0026lt;tbox\u0026gt; \u0026lt;t\u0026gt; \u0026lt;left paren\u0026gt; \u0026lt;period\u0026gt; \u0026lt;right paren\u0026gt; \u0026lt;tbox wkt\u0026gt; ::= \u0026lt;tbox xt\u0026gt; | \u0026lt;tbox x\u0026gt; | \u0026lt;tbox t\u0026gt; \u0026lt;srid\u0026gt; ::= \u0026#39;SRID\u0026#39; \u0026lt;equal\u0026gt; ::= \u0026#39;=\u0026#39; \u0026lt;semicolon\u0026gt; ::= \u0026#39;;\u0026#39; \u0026lt;srid specification\u0026gt; ::= \u0026lt;srid\u0026gt; \u0026lt;equal\u0026gt; \u0026lt;integer\u0026gt; \u0026lt;semicolon\u0026gt; \u0026lt;srid wkt\u0026gt; ::= \u0026lt;srid specification\u0026gt; \u0026lt;semicolon\u0026gt; \u0026lt;x coord\u0026gt; ::= \u0026lt;float\u0026gt; \u0026lt;y coord\u0026gt; ::= \u0026lt;float\u0026gt; \u0026lt;z coord\u0026gt; ::= \u0026lt;float\u0026gt; \u0026lt;coords\u0026gt; ::= \u0026lt;x coord\u0026gt; \u0026lt;y coord\u0026gt; [ \u0026lt;z coord\u0026gt; ] \u0026lt;coords bound\u0026gt; := \u0026lt;left paren\u0026gt; \u0026lt;x coord\u0026gt; \u0026lt;comma\u0026gt; \u0026lt;y coord\u0026gt; [ \u0026lt;comma\u0026gt; \u0026lt;z coord\u0026gt; ] \u0026lt;right paren\u0026gt; \u0026lt;coords span\u0026gt; ::= \u0026lt;left paren\u0026gt; \u0026lt;coords bound\u0026gt; \u0026lt;comma\u0026gt; \u0026lt;coords bound\u0026gt; \u0026lt;right paren\u0026gt; \u0026lt;z\u0026gt; := \u0026#39;Z\u0026#39; \u0026lt;zt\u0026gt; := \u0026#39;ZT\u0026#39; \u0026lt;xz\u0026gt; := \u0026lt;x\u0026gt; | \u0026lt;z\u0026gt; \u0026lt;xzt\u0026gt; := \u0026lt;xt\u0026gt; | \u0026lt;zt\u0026gt; \u0026lt;stbox\u0026gt; ::= \u0026#39;STBOX\u0026#39; | \u0026#39;GEODSTBOX\u0026#39; \u0026lt;stbox st\u0026gt; ::= \u0026lt;stbox\u0026gt; \u0026lt;xzt\u0026gt; \u0026lt;left paren\u0026gt; \u0026lt;coords span\u0026gt; \u0026lt;comma\u0026gt; \u0026lt;period\u0026gt; \u0026lt;right paren\u0026gt; \u0026lt;stbox s\u0026gt; ::= \u0026lt;stbox\u0026gt; \u0026lt;xz\u0026gt; \u0026lt;left paren\u0026gt; \u0026lt;coords span\u0026gt; \u0026lt;right paren\u0026gt; \u0026lt;stbox t\u0026gt; ::= \u0026lt;stbox\u0026gt; \u0026lt;t\u0026gt; \u0026lt;left paren\u0026gt; \u0026lt;period\u0026gt; \u0026lt;right paren\u0026gt; \u0026lt;stbox wkt\u0026gt; ::= \u0026lt;stbox st\u0026gt; | \u0026lt;stbox s\u0026gt; | \u0026lt;stbox t\u0026gt; \u0026lt;bounding box wkt\u0026gt; ::= \u0026lt;period wkt\u0026gt; | \u0026lt;tbox wkt\u0026gt; | \u0026lt;stbox wkt\u0026gt; Temporal types /* Temporal base types */ \u0026lt;double quote\u0026gt; := \u0026#39;\u0026#34;\u0026#39; \u0026lt;bool wkt\u0026gt; = \u0026#39;true\u0026#39; | \u0026#39;t\u0026#39; | \u0026#39;false\u0026#39; | \u0026#39;f\u0026#39; \u0026lt;point\u0026gt; := \u0026#39;POINT\u0026#39; \u0026lt;int wkt\u0026gt; ::= \u0026lt;integer\u0026gt; \u0026lt;float wkt\u0026gt; ::= \u0026lt;float\u0026gt; \u0026lt;text wkt\u0026gt; := \u0026lt;double quote\u0026gt; \u0026lt;string\u0026gt; \u0026lt;double quote\u0026gt; \u0026lt;point wkt\u0026gt; ::= [ \u0026lt;srid wkt\u0026gt; ] \u0026lt;point\u0026gt; [ \u0026lt;z\u0026gt; ] \u0026lt;left paren\u0026gt; \u0026lt;coords\u0026gt; \u0026lt;right paren\u0026gt; \u0026lt;temporal base wkt\u0026gt; ::= \u0026lt;bool wkt\u0026gt; | \u0026lt;int wkt\u0026gt; | \u0026lt;float wkt\u0026gt; | \u0026lt;text wkt\u0026gt; | \u0026lt;point wkt\u0026gt; /* Temporal instant */ \u0026lt;at\u0026gt; ::= \u0026#39;@\u0026#39; \u0026lt;tinstant\u0026gt; ::= \u0026lt;temporal base wkt\u0026gt; \u0026lt;at\u0026gt; \u0026lt;t\u0026gt; \u0026lt;tpoint instant\u0026gt; ::= \u0026lt;point wkt\u0026gt; \u0026lt;at\u0026gt; \u0026lt;t\u0026gt; \u0026lt;tinstant wkt\u0026gt; ::= \u0026lt;tinstant\u0026gt; | \u0026lt;tpoint instant\u0026gt; /* Temporal sequence */ \u0026lt;tsequence discrete\u0026gt; ::= \u0026lt;left brace\u0026gt; \u0026lt;tinstant wkt\u0026gt; {\u0026lt;comma\u0026gt; \u0026lt;tinstant wkt\u0026gt;} ... \u0026lt;right brace\u0026gt; \u0026lt;tpoint sequence discrete\u0026gt; ::= [ \u0026lt;srid wkt\u0026gt; ] \u0026lt;left brace\u0026gt; \u0026lt;tpoint instant wkt\u0026gt; {\u0026lt;comma\u0026gt; \u0026lt;tpoint instant wkt\u0026gt;} ... \u0026lt;right brace\u0026gt; \u0026lt;interpolation\u0026gt; ::= \u0026#39;Interp\u0026#39; \u0026lt;interpolation function\u0026gt; ::= \u0026#39;Stepwise\u0026#39; \u0026lt;interpolation specification\u0026gt; ::= \u0026lt;interpolation\u0026gt; \u0026lt;equal\u0026gt; \u0026lt;interpolation function\u0026gt; \u0026lt;interpolation wkt\u0026gt; ::= \u0026lt;interpolation specification\u0026gt; \u0026lt;semicolon\u0026gt; \u0026lt;srid interpolation wkt\u0026gt; ::= \u0026lt;interpolation wkt\u0026gt; | \u0026lt;srid wkt\u0026gt; | \u0026lt;srid specification\u0026gt; \u0026lt;comma\u0026gt; \u0026lt;interpolation specification\u0026gt; \u0026lt;semicolon\u0026gt; \u0026lt;tsequence continuous\u0026gt; ::= [ \u0026lt;interpolation wkt\u0026gt; ] \u0026lt;left bound\u0026gt; \u0026lt;tinstant wkt\u0026gt; {\u0026lt;comma\u0026gt; \u0026lt;tinstant wkt\u0026gt;} ... \u0026lt;right bound\u0026gt; \u0026lt;tpoint sequence continuous\u0026gt; ::= [ \u0026lt;srid interpolation wkt\u0026gt; ] \u0026lt;left bound\u0026gt; \u0026lt;tpoint instant wkt\u0026gt; {\u0026lt;comma\u0026gt; \u0026lt;tpoint instant wkt\u0026gt;} ... \u0026lt;right bound\u0026gt; \u0026lt;tsequence wkt\u0026gt; ::= \u0026lt;tsequence discrete\u0026gt; | \u0026lt;tpoint sequence discrete\u0026gt; | \u0026lt;tsequence continuous\u0026gt; | \u0026lt;tpoint sequence continuous\u0026gt; /* Temporal sequence set */ \u0026lt;tsequence set\u0026gt; ::= [ \u0026lt;interpolation wkt\u0026gt; ] \u0026lt;left brace\u0026gt; \u0026lt;tsequence wkt\u0026gt; {\u0026lt;comma\u0026gt; \u0026lt;tsequence wkt\u0026gt;} ... \u0026lt;right brace\u0026gt; \u0026lt;tpoint sequence set\u0026gt; ::= [ \u0026lt;srid interpolation wkt\u0026gt; ] \u0026lt;left brace\u0026gt; \u0026lt;tpoint sequence wkt\u0026gt; {\u0026lt;comma\u0026gt; \u0026lt;tpoint sequence wkt\u0026gt;} ... \u0026lt;right brace\u0026gt; \u0026lt;tsequence set wkt\u0026gt; ::= \u0026lt;tsequence set\u0026gt; | \u0026lt;tpoint sequence set\u0026gt; /* Temporal type */ \u0026lt;temporal wkt\u0026gt; ::= \u0026lt;tinstant wkt\u0026gt; | \u0026lt;tsequence wkt\u0026gt; | \u0026lt;tsequence set wkt\u0026gt; Examples of values Span types \u0026#34;[19, 21]\u0026#34; \u0026#34;(74, 83)\u0026#34; \u0026#34;[59.14400641946122, 67.4557671439834)\u0026#34; \u0026#34;(42.34679828863591, 50.27122142305598]\u0026#34; \u0026#34;[2001-04-26 09:11:00+02, 2001-04-26 09:18:00+02]\u0026#34; \u0026#34;[2001-03-14 20:43:00+01, 2001-03-14 20:51:00+01)\u0026#34; Time types \u0026#34;{2001-01-23 08:13:00+01, 2001-01-23 08:16:00+01, 2001-01-23 08:19:00+01}\u0026#34; \u0026#34;{2001-01-23 08:13:00+01}\u0026#34; \u0026#34;{(2001-05-29 11:20:00+02, 2001-05-29 11:21:00+02], (2001-05-29 11:24:00+02, 2001-05-29 11:27:00+02)}\u0026#34; \u0026#34;{(2001-10-18 19:46:00+02, 2001-10-18 19:50:00+02)}\u0026#34; Box types \u0026#34;TBOX XT([85.631867, 89.408875],[2001-09-07 00:20:00+02, 2001-09-07 00:26:00+02])\u0026#34; \u0026#34;TBOX X([85.631867, 89.408875])\u0026#34; \u0026#34;TBOX T([2001-09-07 00:20:00+02, 2001-09-07 00:26:00+02])\u0026#34; \u0026#34;STBOX XT(((30.266616,74.668954),(32.743667,84.470892)),[2001-11-19 12:39:00+01, 2001-11-19 12:46:00+01])\u0026#34; \u0026#34;SRID=5676;STBOX X(((30.266616,74.668954),(32.743667,84.470892)))\u0026#34; \u0026#34;STBOX T(([2001-11-19 12:39:00+01, 2001-11-19 12:46:00+01])\u0026#34; \u0026#34;STBOX ZT(((53.986894,30.334541,42.518891),(56.040446,37.764663,49.610776)),[2001-08-14 12:26:00+02, 2001-08-14 12:28:00+02])\u0026#34; \u0026#34;STBOX Z(((53.986894,30.334541,42.518891),(56.040446,37.764663,49.610776)))\u0026#34; \u0026#34;STBOX T([2001-08-14 12:26:00+02, 2001-08-14 12:28:00+02])\u0026#34; \u0026#34;SRID=4326;GEODSTBOX ZT(((18.055912,63.50315,827.645472),(21.462877,65.39722,832.587446)),[2001-02-12 15:48:00+01, 2001-02-12 15:56:00+01]) Temporal types /* Temporal instant */ \u0026#34;true@2022-01-01 08:00:00+02\u0026#34; \u0026#34;1@2022-01-01 08:00:00+02\u0026#34; \u0026#34;2.5@2022-01-01 08:00:00+02\u0026#34; \u0026#34;walking@2022-01-01 08:00:00+02\u0026#34; \u0026#34;POINT(0 0)@2022-01-01 08:00:00+02\u0026#34; \u0026#34;SRID=5676;Point(1 1)@2022-01-01 08:00:00+02\u0026#34; /* Temporal discrete sequence */ \u0026#34;{true@2022-01-01 08:00:00+02, false@2022-01-01 08:10:00+02} \u0026#34; \u0026#34;{1@2022-01-01 08:00:00, 2@2022-01-01 09:00:00+02}\u0026#34; \u0026#34;SRID=5676;{POINT(1 1)@2022-01-01 08:00:00+02, POINT(2 2)@2022-01-01 09:00:00+02}\u0026#34; /* Temporal continuous sequence \u0026#34;[1@2022-01-01 08:00:00+02, 2@2022-01-01 09:00:00+02, 1@2022-01-01 09:30:00+02]\u0026#34; \u0026#34;Interp=Stepwise;[1@2022-01-01 08:00:00+02, 2@2022-01-01 09:00:00+02, 1@2022-01-01 09:30:00]+02\u0026#34; \u0026#34;[POINT(1 1)@2022-01-01 08:00:00+02, POINT(2 2)@2022-01-01 09:00:00+02]\u0026#34; \u0026#34;SRID=5676;[POINT(1 1)@2022-01-01 08:00:00+02, POINT(2 2)@2022-01-01 09:00:00+02]\u0026#34; \u0026#34;Interp=Stepwise;[POINT(1 1)@2022-01-01 08:00:00+02, POINT(2 2)@2022-01-01 09:00:00+02]\u0026#34; \u0026#34;SRID=5676,Interp=Stepwise;[POINT(1 1)@2022-01-01 08:00:00+02, POINT(2 2)@2022-01-01 09:00:00+02]\u0026#34; /* Temporal sequence set */ \u0026#34;{[driving@2022-01-01 08:00:00+02, driving@2022-01-01 09:00:00+02], [walking@2022-01-01 10:00:00+02, walking@2022-01-01 11:00:00+02]}\u0026#34; \u0026#34;{[POINT(1 1)@2022-01-01 08:00:00+02, POINT(2 2)@2022-01-01 09:00:00+02], [POINT(3 3)@2022-01-01 10:00:00+02, POINT(3 3)@2022-01-01 11:00:00+02]}\u0026#34; \u0026#34;SRID=5676;{[POINT(1 1)@2022-01-01 08:00:00+02, POINT(2 2)@2022-01-01 09:00:00+02], [POINT(3 3)@2022-01-01 10:00:00+02, POINT(3 3)@2022-01-01 11:00:00+02]}\u0026#34; Writing WKT Because WKT is a decimal text output, it will never be able to exactly represent the underlying machine representation of floating point number and in particular coordinates of temporal point. In general, WKT is used for display to humans, or for transport when exact coordinate representation is not required (some web applications).\nAccordingly, MEOS allows you to customize the coordinate precision and rounding behaviour, as well as the dimensionality of WKT output.\n/* Read an instant */ const char *wkt_in = \u0026#34;Point(1 1 1,2 2 2)@2022-01-01\u0026#34;; TInstant *inst = tgeompoint_from_text(inst_str); /* * Generate the output WKT * The first argument sets the number places after the decimal to output in WKT. Default 16. * The second argument sets the number of dimension to output in WKT. Default is as in the data. */ unsigned char *wkt = tgeompoint_as_text(inst, 6, 2); /* Continue processing ... */ /* Free the allocated memory */ free(wkt_in); free(wkt_out); free(inst); "},{"id":5,"href":"/documentation/aggregation/","title":"Aggregate Operations","parent":"Documentation","content":"We explain next the aggregate operations for temporal types. These operations use a skip list for their implementation.\nComputation Model MEOS borrows from PostgreSQL the computation model for aggregate operations. These operations are defined in terms of state values, state transition functions, and final functions. An aggregate operation uses a state value that is updated as each successive input value is processed. The data type for the state value depends on the aggregate operation. It is a set or a span type when aggregating time values, or a temporal type when aggregating temporal values. The state transition function takes the previous state value and the aggregate\u0026rsquo;s current value, and returns a new state value. A final function takes the ending state value and returns the aggregate result.\nAn example of usage of aggregate operations in MEOS is given here.\nSkip Lists We explain next the skip list structure implemented in MobilityDB for efficiently implementing temporal aggregate operations. The struture is illustrated in the figure below.\nThe skip list structure contains the following elements. elemType contains the type of elements stored in the skip list. capacity is the maximum number of elements the skip list can currently store. next is the index of the free next element. length is the current number of values stored. freed is an array containing the indexes of the elements deleted whose space can be reused. freecount is the number of deleted elements. freecap is the current size of the freed array. tail is the index of the tail element of the list. extra is a pointer to a structure containing additional information to be passed to the aggregate function. This is used when aggregating temporal points to keep the SRID and the dimensionality of the values. extrasize is the size of the extra structure. elems is an array containing the elements of the skip list.\nAs shown in the figure, to minimize memory allocation operations, the skip list uses a contiguous memory space for its elements. This is to contrast with an alternative implementation in which every element of the skip list is allocated individually as in the figure shown here. Each element contains a value (shown in the yellow boxes), its current height, and an array of pointers (of size four in the figure) to other elements. Due to its memory structure, the pointers between skip list elements are not actually pointers, but values of the index of the element pointed to. This is implied in the figure by the dashed arrows. The grayed cells in the figure show unused pointers, that is, those whose index is greater that the current height of the element. The array of skip list elements is an expandable struture, it will expand automatically when it is full.\nIn the figure, the values 1 to 10 represent timestamps. In this case, the values stored in the skip list are passed by value and thus the skip list element contains the value. If on the contrary, the values stored in the skip list are passed by reference, as is the case for spans or for temporal values, a pointer to the address where the structure is located will be stored as value of the element.\nThe figure below shows the contents of the skip list after removing the element with value 9. As can be seen, the array freed contains the indexes of the elements deleted and whose space can be reused.\nFinally, the next figure shows the contents of the skip list after inserting the element with value 11.\nAs can be seen, the free value from the previous delete is reused when inserting a new value. If there are no more free values to be reused, the new value will be stored at the next available place of the structure and the pointers will be updated similarly.\n"},{"id":6,"href":"/tutorialprograms/meos_aggregate_berlinmod/","title":"Aggregating Trips","parent":"Tutorial Programs","content":"meos_aggregate_berlinmod.c\nThis program reads a CSV file containing synthetic trip data in Brussels generated by the MobilityDB-BerlinMOD generator and computes\nthe extent, that is, the bounding box of the spatial and time dimensions represented as an STBOX the temporal count, that is, the evolution on time of the number of vehicles travelling at an hour granularity. The output of the program is given next.\n61 trip records read Extent ------ SRID=3857;STBOX XT(((473212.810151,6578740.528027),(499152.544688,6607165.513683)),[2020-06-01 08:01:23.238+02, 2020-06-05 01:28:43.407526+02]) Temporal count -------------- [3@2020-06-01 08:00:00+02, 2@2020-06-01 10:00:00+02, 2@2020-06-01 11:00:00+02) [2@2020-06-01 16:00:00+02, 3@2020-06-01 17:00:00+02, 3@2020-06-01 19:00:00+02) [1@2020-06-01 20:00:00+02, 2@2020-06-01 21:00:00+02, 1@2020-06-01 23:00:00+02, 1@2020-06-02 00:00:00+02) [4@2020-06-02 08:00:00+02, 3@2020-06-02 09:00:00+02, 2@2020-06-02 10:00:00+02, 2@2020-06-02 11:00:00+02) [2@2020-06-02 16:00:00+02, 4@2020-06-02 17:00:00+02, 2@2020-06-02 18:00:00+02, 2@2020-06-02 19:00:00+02) [1@2020-06-02 20:00:00+02, 2@2020-06-02 21:00:00+02, 1@2020-06-02 22:00:00+02, 1@2020-06-02 23:00:00+02) [4@2020-06-03 08:00:00+02, 5@2020-06-03 09:00:00+02, 1@2020-06-03 10:00:00+02, 1@2020-06-03 11:00:00+02) [3@2020-06-03 16:00:00+02, 5@2020-06-03 17:00:00+02, 2@2020-06-03 18:00:00+02, 2@2020-06-03 19:00:00+02) [2@2020-06-03 20:00:00+02, 1@2020-06-03 22:00:00+02, 1@2020-06-03 23:00:00+02) [2@2020-06-04 08:00:00+02, 4@2020-06-04 09:00:00+02, 1@2020-06-04 10:00:00+02, 1@2020-06-04 11:00:00+02) [5@2020-06-04 16:00:00+02, 5@2020-06-04 18:00:00+02) [1@2020-06-04 20:00:00+02, 3@2020-06-04 21:00:00+02, 2@2020-06-04 23:00:00+02, 1@2020-06-05 00:00:00+02, 1@2020-06-05 02:00:00+02) A similar result can be obtained in MobilityDB with the following SQL queries, assuming that the CSV file has been previously loaded into the trips table.\nSELECT extent(trip) FROM trips; SELECT unnest(sequences(tcount(tprecision(getTime(trip), interval \u0026#39;1 hour\u0026#39;, timestamptz \u0026#39;2020-06-01\u0026#39;)))) FROM trips; "},{"id":7,"href":"/tutorialprograms/meos_assemble_ais/","title":"Assembling Trips","parent":"Tutorial Programs","content":"meos_assemble_ais.c\nThis program reads AIS data from a CSV file, constructs trips from these records, and outputs for each trip the MMSI, the number of instants, and the distance travelled.\nThe output of the program is given next.\n156837 records read. 0 incomplete records ignored. 5 trips read. MMSI: 265513270, Number of input instants: 21799, Number of instants: 6, Distance travelled 11.695976 MMSI: 219027804, Number of input instants: 38326, Number of instants: 3285, Distance travelled 64865.704162 MMSI: 566948000, Number of input instants: 26619, Number of instants: 2969, Distance travelled 14932.332003 MMSI: 219001559, Number of input instants: 48323, Number of instants: 1597, Distance travelled 5202.381849 MMSI: 257136000, Number of input instants: 21770, Number of instants: 14811, Distance travelled 647535.585339 The above ouput shows the normalization process that takes place in MEOS. In the first example above, from 21799 observations only 6 of them were necessary to represent the same information. Normalization achieves lossless compression by removing redundant instants. For example, three consecutive instant values can be merged into two if they have the same value. As another example, three consecutive instant values can be merged into two if the linear functions defining the evolution of values over time are the same. Normalization may achieve up to 400% lossless compression of real-world mobility data. Indeed, many observations that are collected, e.g., while a vehicle is stopped at a red light or in a traffic jam are redudant and can be safely removed without losing any information.\nA similar result can be obtained in MobilityDB with the following SQL query, assuming that the CSV file has been previously loaded into the AISInput table.\nWITH temp1(MMSI, NoInputInst) AS ( SELECT MMSI, COUNT(*) FROM AISInput GROUP BY MMSI ), temp2(MMSI, trip) AS ( SELECT MMSI, tgeogpoint_seq(array_agg(tgeogpoint_inst( ST_SetSRID(ST_Point(longitude, latitude), 4326), t) ORDER BY t)) FROM AISInput GROUP BY MMSI ) SELECT t1.MMSI, NoInputInst, numInstants(trip) AS NoInst, to_char(length(trip), \u0026#39;999990D999999\u0026#39;) AS Distance FROM temp1 t1, temp2 t2 WHERE t1.MMSI = t2.MMSI; "},{"id":8,"href":"/tutorialprograms/meos_clip_berlinmod/","title":"Clipping Trips to Geometries","parent":"Tutorial Programs","content":"meos_clip_berlinmod.c\nThis program reads a CSV file containing synthetic trip data in Brussels generated by the MobilityDB-BerlinMOD generator and computes the distance traversed by the trips in the 19 Brussels municipalities (communes in French).\nThe output of the program is given next.\n19 commune records read Brussels region record read Reading trip records ******************************************************* 55 trip records read. ----------------------------------------------------------------------------------------------------------------------------------------- | Commmunes ----------------------------------------------------------------------------------------------------------------------------------------------------- Veh | Distance | 2 4 6 7 9 10 11 12 14 15 16 17 18 19 | Inside | Outside --------------------------------------------------------------------------------------------------------------------------------------------------------- 1 | 256.641 | 14.585 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 8.223 11.915 0.000 0.000 | 34.724 | 221.917 2 | 126.289 | 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 77.281 4.583 28.809 0.000 0.000 | 110.673 | 15.616 3 | 316.302 | 0.000 5.194 56.414 0.000 0.000 0.000 0.000 17.132 9.017 0.000 48.214 0.000 74.502 1.951 | 212.425 | 103.877 4 | 90.095 | 0.000 0.000 0.000 18.094 35.514 10.832 11.738 0.000 0.000 0.000 13.917 0.000 0.000 0.000 | 90.095 | 0.000 5 | 147.076 | 0.000 0.000 0.000 0.000 0.000 0.000 4.170 0.000 0.000 0.000 107.440 0.000 0.000 0.000 | 111.611 | 35.465 --------------------------------------------------------------------------------------------------------------------------------------------------------- | 936.402 | 14.585 5.194 56.414 18.094 35.514 10.832 15.908 17.132 9.017 77.281 182.377 40.724 74.502 1.951 | 559.527 | 376.875 --------------------------------------------------------------------------------------------------------------------------------------------------------- Notice that communes having a total distance of zero are not shown above. To show all communes it suffices to set a Boolean flag in the program.\nA similar result can be obtained in MobilityDB with the following SQL queries, assuming that the CSV files have been previously loaded into the trips, brusselsRegion, and communes table.\nSELECT vehid, to_char(SUM(length(trip)) / 1e3,\u0026#39;999990D999\u0026#39;) AS totdist, to_char(SUM(length(atGeometry(trip, b.geom))) / 1e3,\u0026#39;999990D999\u0026#39;) AS inside, to_char((SUM(length(trip)) - SUM(length(atGeometry(trip, b.geom)))) / 1e3, \u0026#39;999990D999\u0026#39;) AS outside FROM trips t, brusselsRegion b GROUP BY GROUPING SETS ((vehid), ()) ORDER BY vehid; vehid | totdist | inside | outside -------+-------------+-------------+------------- 1 | 256.641 | 34.724 | 221.917 2 | 126.289 | 110.673 | 15.616 3 | 316.302 | 212.425 | 103.877 4 | 90.095 | 90.095 | 0.000 5 | 147.076 | 111.611 | 35.465 | 936.402 | 559.527 | 376.875 SELECT t.vehid, c.id AS commId, to_char(SUM(length(atGeometry(t.trip, c.geom))) / 1e3,\u0026#39;999990D999\u0026#39;) AS commdist FROM trips t, communes c GROUP BY GROUPING SETS ((vehid, c.id),(c.id)) HAVING SUM(length(atGeometry(t.trip, c.geom))) IS NOT NULL ORDER BY t.vehid, c.id; vehid | commid | commdist -------+--------+------------- 1 | 2 | 14.585 1 | 16 | 8.223 1 | 17 | 11.915 2 | 15 | 77.281 2 | 16 | 4.583 2 | 17 | 28.809 3 | 4 | 5.194 3 | 6 | 56.414 3 | 12 | 17.132 3 | 14 | 9.017 3 | 16 | 48.214 3 | 18 | 74.502 3 | 19 | 1.951 4 | 7 | 18.094 4 | 9 | 35.514 4 | 10 | 10.832 4 | 11 | 11.738 4 | 16 | 13.917 5 | 11 | 4.170 5 | 16 | 107.440 | 2 | 14.585 | 4 | 5.194 | 6 | 56.414 | 7 | 18.094 | 9 | 35.514 | 10 | 10.832 | 11 | 15.908 | 12 | 17.132 | 14 | 9.017 | 15 | 77.281 | 16 | 182.377 | 17 | 40.724 | 18 | 74.502 | 19 | 1.951 "},{"id":9,"href":"/documentation/datamodel/","title":"Data Model","parent":"Documentation","content":" Temporal Types MEOS provides temporal types, which represent the evolution on time of values of some element type, called the base type of the temporal type. For instance, a temporal integer may be used to represent the evolution on time of the gear used by a moving car. In this case, the data type is temporal integer and the base type is integer. Similarly, a temporal float may be used to represent the evolution on time of the speed of a car. As another example, a temporal point may be used to represent the evolution on time of the location of a car, as reported by GPS devices. Temporal types are useful because representing values that evolve in time is essential in many applications, especially in mobility applications. Furthermore, the operators on the base types (such as arithmetic operators for integers and floats, spatial relationships and distance for geometries) can be intuitively generalized when the values evolve in time.\nMEOS has six built-in temporal types, namely tbool, tint, tfloat, ttext, tgeompoint, and tgeogpoint, which are, respectively, based on PostgreSQL alphanumeric types bool (a Boolean value), int (a 4-byte integer number), float (an 8-byte floating point number), and text (a string of characters of variable size), as well as the geospatial base types geometry, and geography from PostGIS restricted to 2D or 3D points with Z dimension.\nThe interpolation of a temporal value states how the value evolves between successive instants. The interpolation is discrete when the value is unknown between two successive instants. They can represent, for example, checkins/checkouts when using an RFID card reader to enter/exit a building. The interpolation is linear when the value evolves linearly between two successive instants. For example, the speed of a car may be represented with a temporal float, which indicates that the values are known at the two time instants but continuously evolve between them. Similarly, the location of a vehicule may be represented by a temporal point where the location between two consecutive GPS readings is obtained by linear interpolation. Finally, the interpolation is stepwise when the value remains constant between two successive instants. For example, the gear used by a moving car may be represented with a temporal integer, which indicates that its value is constant between two time instants. Temporal types based on discrete base types (that is tbool, tint, or ttext) may evolve in a discrete or stepwise manner. On the other hand, temporal types based on continuous base types (that is tfloat, tgeompoint, or tgeogpoint) may evolve in a discrete, linear, or stepwise manner.\nThe subtype of a temporal value states the temporal extent at which the evolution of values is recorded. Temporal values come in thee subtypes, explained next.\nA temporal value of instant subtype (briefly, an instant value) represents the value at a time instant, for example\n'17@2018-01-01 08:00:00'\nA temporal value of sequence subtype (briefly, a sequence value) represents the evolution of the value during a sequence of time instants, where the values between these instants are interpolated using either a discrete, a linear, or a stepwise function (see above). A graphical represention of sequence values with the three interpolations are given next.\nExamples of values for the three interpolations are given next:\n-- Discrete interpolation \u0026#39;{17@2018-01-01 08:00:00, 17.5@2018-01-01 08:05:00, 18@2018-01-01 08:10:00}\u0026#39; -- Linear interpolation \u0026#39;(10@2018-01-01 08:00:00, 20@2018-01-01 08:05:00, 15@2018-01-01 08:10:00]\u0026#39; -- Stepwise interpolation \u0026#39;Interp=Stepwise;(10@2018-01-01 08:00:00, 20@2018-01-01 08:05:00, 15@2018-01-01 08:10:00]\u0026#39; As can be seen, a sequence value has a lower and an upper bound that can be either inclusive, represented by [ and ], or exclusive, represented by ( and ). By definition, both bounds must be inclusive when the interpolation is discrete or when the sequence has a single instant such as '[10@2018-01-01 08:00:00]'. The latter is called an instantaneous sequence.\nThe value of a temporal sequence with linear or stepwise interpolation is interpreted by assuming that the period of time defined by every pair of consecutive values v1@t1 and v2@t2 is lower inclusive and upper exclusive, unless they are the first or the last instants of the sequence and in that case the bounds of the whole sequence apply. Furthermore, the value taken by the temporal sequence between two consecutive instants depends on whether the interpolation is linear or stepwise. For example, the temporal sequence above\n'(10@2018-01-01 08:00:00, 20@2018-01-01 08:05:00, 15@2018-01-01 08:10:00]'\nrepresents that the value evolves from 10 to 20 during (2018-01-01 08:00:00, 2018-01-01 08:05:00) and evolves from 20 to 15 during [2018-01-01 08:05:00,2018-01-01 08:10:00]. On the other hand, the temporal sequence above\n'Interp=Stepwise;(10@2018-01-01 08:00:00, 20@2018-01-01 08:05:00, 15@2018-01-01 08:10:00]'\nrepresents that the value is 10 during (2018-01-01 08:00:00, 2018-01-01 08:05:00), 20 during [2018-01-01 08:05:00,2018-01-01 08:10:00), and 15 at the end instant 2018-01-01 08:10:00.\nFinally, a temporal value of sequence set subtype (briefly, a sequence set value) represents the evolution of the value at a set of sequences, where the values between these sequences are unknown. A graphical represention of sequence set values with different interpolations are given next.\nAs shown above, sequence set values can only be of linear or stepwise interpolation. Furtheremore, all composing sequences of a sequence set value must be of the same interpolation.\nExamples of sequence set values are as follows:\n-- Linear Interpolation \u0026#39;{[17@2018-01-01 08:00:00, 17.5@2018-01-01 08:05:00], [18@2018-01-01 08:10:00, 18@2018-01-01 08:15:00]}\u0026#39; -- Stepwise Interpolation \u0026#39;Interp=Stepwise;{[17@2018-01-01 08:00:00, 17.5@2018-01-01 08:05:00], [18@2018-01-01 08:10:00, 18@2018-01-01 08:15:00]}\u0026#39; A rich set of functions is available to perform various operations on temporal types. The developer\u0026rsquo;s documentation available at docs.libmeos.org give a detailed description of these functions.\nEach temporal type is associated to another type, referred to as its bounding box, which represent its extent in the value and/or the time dimension. The bounding box of the various temporal types are as follows:\nThe tstzspan type (see below) for the tbool and ttext types, where only the temporal extent is considered. A TBox (temporal box) type for the tint and tfloat types, where the value extent is defined in the X dimension and the temporal extent in the T dimension. An STBox (spatiotemporal box) type for the tgeompoint and tgeogpoint types, where the spatial extent is defined in the X, Y, and Z dimensions (where the Z dimension is optional), and the temporal extent in the T dimension. Set and Span Types MEOS provides span and span set types (corresponding to PostgreSQL range and multirange types) for defining ranges of values. Examples of span types are intspan, floatspan, and tstzspan, which represent, respectively, ranges of integer, float, and timestamp with time zone values. Examples of values for the span types are as follows.\n-- Integer span \u0026#39;[17, 18)\u0026#39; -- Float span \u0026#39;(17.5, 18.5]\u0026#39; -- Timestamp with time zone span \u0026#39;[2018-01-01 08:00:00, 2018-01-01 08:10:00]\u0026#39; Examples of span set types are intspanset, floatspanset, and tstzspanset, which represent sets of spans. Examples of values for the span types are as follows.\n-- Integer span set \u0026#39;{[17, 18), [19, 20)}\u0026#39; -- Float span set \u0026#39;{[17.5, 18.5), [19.5, 20.5)}\u0026#39; -- Timestamp with time zone span set \u0026#39;{[2018-01-01 08:00:00, 2018-01-01 08:10:00], [2018-01-01 08:20:00, 2018-01-01 08:30:00]}\u0026#39; MEOS also provides set types for representing set of values. Examples of set types are intset, floatset, and tstzset, which represent, respectively, set of integer, float, and timestamp with time zone values. Examples of values for the set types are as follows.\n-- Integer set \u0026#39;{17, 18, 19, 20}\u0026#39; -- Float set \u0026#39;{17.5, 18.5, 19.5, 20.5}\u0026#39; -- Timestamp with time zone set \u0026#39;{2018-01-01 08:00:00, 2018-01-01 08:10:00, 2018-01-01 08:20:00, 2018-01-01 08:30:00}\u0026#39; Finally, MEOS also provides PostgreSQL date/time types, namely, Timestamp, TimestampTz, DateADT, Time, and Interval, in addition to the base types bool, int, float, and text.\n"},{"id":10,"href":"/documentation/datastructures/","title":"Data Structures","parent":"Documentation","content":" Temporal Types Although MEOS is written in C, it aims at using well-proven object-oriented concepts for its development. The data model for the temporal types is implemented using the following conceptual type hierarchy.\nThe supertype Temporal is a template type since it is used for all temporal types, such as temporal integers or temporal points. Temporal is also an abstract type, since it cannot be instantiated, only its subtypes can. Temporal types are variable-length types: the size of an instance in bytes is kept in the size attribute. The specific type of an instance (such as tintor tfloat) is defined in the temptype attribute. The specific subtype of an instance (such as TInstantor TSequence) is specified in the subtype attribute. Finally, the interpolation attribute keeps the interpolation used, which can be discrete, linear, or stepwise.\nThe type TInstant is used for representing a single observation composed of a value and a timestamp t. Timestamps in MEOS keep associated time zone information and are stored using PostgreSQL format, that is, in microseconds from January 1st, 2000 at 00:00:00 in Coordinated Universal Time (UTC), which is equal to Greenwich Mean Time (GMT). Notice that other systems, for example PostGIS trajectories, use Unix time in which time is represented in milliseconds from January 1st, 1970 at 00:00:00 UTC. In temporal instant values, the flags attribute specifies whether the value is passed by value or by reference, or whether the base type is discrete or continuous.\nThe type TSequence is used for representing a set of observations where an interpolation function is used for determining the value between observations. MEOS provides three interpolation functions: discrete, where the value is unknown between observations, stepwise where the value remains constant between consecutive observations, and linear, where the value evolves linearly between consecutive observations. For temporal sequence values, the flags attribute specifies the interpolation function used. The count attribute specifies the number of observations, the bbox attribute specifies the bounding box that encompasses them, and the instants attribute keeps the observations. The bounding box can be of various types depending on the temporal type:\nfor tbool and ttext it is a period keeping only the time extent, for tint and tfloat it is a TBox composed of a period for the time extent and a floatspan for the value extent, and for tgeompoint and tgeogpoint it is an STBox keeping a period for the time extent and the minimum and maximum values of the 2D/3D coordinates for the spatial extent. The type TSequenceSet is used for representing a set of sequences having the same interpolation function that may have temporal gaps where the value is not known. This situation typically arrives in real-world applications due to signal loss. The count attribute specifies the number of such sequences, while the totalcount attribute specifies the number of observations across all sequences. Finally, the bbox attribute specifies the bounding box that encompasses all observations and the sequences attribute keeps the composing sequences.\nThe following figure shows the C structures implementing the above conceptual type hierarchy for temporal types.\nThe structures for all temporal types start with a header, which contains information in the Temporal supertype above shared for all subtypes. It is composed of the size (Z), temptype (T), subtype (S), and flags (F). The flags encodes metadata information such as whether the base values are passed by value or by reference, whether the base values are discrete (e.g., int) or continuous (e.g., float), the interpolation function used, whether the spatial values have a Z dimension, etc.\nThe TInstant structure stores after the header the timestamp t and the base value.\nThe TSequence structure stores after the header the attributes count and maxcount, which state, respectively, the current and maximum number of composing values of type TInstant, bboxsize that stores the size of the bounding box, and bbox that stores the bounding box. As indicated in the figure, all bounding boxes start with a period for the time extent, and contain other attributes for temporal numbers (TBox) and temporal points (STBox). The structure contains an array of òffsets, storing the offset of the location of each composing instant with respect to the start of the structure. Therefore, the address of each composing instant can be easily obtained by adding its òffset to the address of the structure. The òffsets array also acts as a temporal index, since the instants are stored in ascending order of timestamp. This enables a binary search of the array, for example, when looking for the value at a given timestamp. This temporal index, combined with the bounding box that is used to quickly filter out values that do not satisfy a predicate, enables an efficient implementation of the temporal operations. Then, the structure stores the composing instants.\nFinally, the TSequenceSet structure has similar structure as the TSequence structure, where count and maxcount state the current and maximum number of composing values of type TSequence, totalcount states the total number of instants accross all composing sequences, followed by the size of the bounding box bboxsize, the bounding box bbox, the offsets array, and the composing sequences.\nBoth the TSequence and TSequenceSet structures are expandable, that is, at the creation time they can allocate space available for storing additional observations later, as stated by the count and maxcount attributes. Furthermore, both structures automatically expand upon update operations when there is no more available space, where by default the size is doubled at each expansion. These features are essential for streaming applications. On the other hand, for historical (that is, batch) processing, the operations create structures without any additional space by simply calling the constructors with the same value for count and maxcount.\nSet and Span Types MEOS uses set, span, and span set types for representing finite subsets of values from the base and time types. These types are template types, since they are used for constructing multiple types.\nThe following figure shows the C structures for these types.\nThe Set structure comes in two variants, depending on whether the values in the set are passed by value or by reference, depicted, respectively, in the topmost and the second structure. The header contains the size (Z), settype (B), basetype (B), and flags (F). Here, the flags encodes metadata information such as whether the values in the set are passed by value or by reference and whether the values in the set are stored in ascending order or not. The bboxsize attribute keeps the size of the bounding box and bbox stores the bounding box. As suggested by the dashed box, the bounding box may not be present, which is the case for alphanumeric values. For spatial values, the bounding box is a spatiotemporal box (STBox) keeping the minimum and maximum values of the 2D/3D coordinates for the spatial extent.\nWhen the values in the set are passed by value, they are stored immediately after the bounding box. Otherwise, the structure contains an array of òffsets, storing the offset of the location of each value with respect to the start of the structure. Therefore, the address of each value can be easily obtained by adding its òffset to the address of the structure. Notice that the òffsets array is only necessary when the values of the set are of variable length, as is the case for the type textset, which contains text values. The òffsets array also act as an index when the set is ordered, since a binary search of the array is performed when looking for a given value. This index, combined with the bounding box that is used to quickly filter out values that do not satisfy a predicate, enables an efficient implementation of the set operations.\nThe Span structure starts with a header, composed of the spantype (S), basetype (B), lower_inc (L), and upper_inc (U), where the two latter elements state, respectively, whether the lower and upper bounds are inclusive or not. Then, the structure stores the values of the lower and upper bounds.\nFinally, the SpanSet structure starts with a header, composed of the size (Z), spansettype (T), spantype (S), and basetype (B). It is followed by the count attribute, which states the number of composing values of type Span, and the bounding span. The composing span values are kept in the elems array. Since the spans are stored in ascending order, this enables a binary search of the array when, for example, looking whether a given value is contained in the span set. Combined with the bounding box that is used to quickly filter out values that do not satisfy a predicate, this enables an efficient implementation of span set operations.\nBounding Box Types MEOS uses bounding boxes for efficient manipulation of temporal types. For example, when determining whether a temporal point (e.g., a moving vehicle) overlaps a geometry (e.g., a county), a bounding box test is applied to quickly filter out the temporal points whose bounding box does not overlap the bounding box of the geometry. Then, the computation continues for the values satisfying the bounding box test.\nMEOS has three types of bounding boxes depicted next.\nThe Span type, already described above, is used for temporal types such as tbool and ttext and in this case the bounding box only represents the temporal extent of the value.\nThe TBox type is used for temporal numbers such as tint and tfloat, where the span attribute represents the value extent and the period attribute represents the temporal extent of the value.\nFinally, the STBox type is used for temporal points such as tgeompoint and tgeogpointt, where the period attribute represents the temporal extent of the value, the attributes such as xmin and xmax represent the 2D or 3D spatial extent of the values, the attribute srid identifies the coordinate system, and the flags attribute keeps information such as whether the coordinate system is Cartesian or geodetic.\n"},{"id":11,"href":"/tutorialprograms/meos_disassemble_berlinmod/","title":"Disassembling Trips","parent":"Tutorial Programs","content":"meos_disassemble_berlinmod.c\nThis program reads a CSV file containing synthetic trip data in Brussels generated by the MobilityDB-BerlinMOD generator, disassembles the trips into individual observations, and write them in a CSV file ordered by timestamp.\nThe output of the program is given next.\n55 trip records read. 76024 observation records written. The CSV file generated by the program is given next.\ntripid,vehid,day,seqno,geom,t 3,3,2020-06-01,1,POINT(496102.813654 6595154.145012),2020-06-01 08:10:09.852+02 3,3,2020-06-01,1,POINT(496105.474664 6595158.378099),2020-06-01 08:10:11.352+02 3,3,2020-06-01,1,POINT(496107.99001 6595162.379464),2020-06-01 08:10:12.202733+02 [...] A similar result can be obtained in MobilityDB with the following SQL commands.\nCREATE TABLE trips(tripid int, vehid int, day date, seqno int, trip tgeompoint, trip_input text); COPY trips(tripid, vehid, day, seqno, trip_input) FROM \u0026#39;/home/MobilityDB/meos/examples/trips.csv\u0026#39; CSV HEADER; UPDATE trips set trip = tgeompointFromHexEWKB(trip_input); ALTER TABLE trips DROP COLUMN trip_input; COPY ( WITH temp(tripid, vehid, day, seqno, inst) AS ( SELECT tripid, vehid, day, seqno, unnest(instants(trip)) AS inst FROM trips ORDER BY inst ) SELECT tripid, vehid, day, seqno, ST_AsEWKT(getValue(inst)) AS geom, getTimestamp(inst) AS t FROM temp ) TO \u0026#39;/home/MobilityDB/meos/examples/trip_instants.csv\u0026#39; CSV HEADER; "},{"id":12,"href":"/documentation/","title":"Documentation","parent":"MEOS","content":""},{"id":13,"href":"/documentation/modification/","title":"Modification Operations","parent":"Documentation","content":"We explain next the semantics of the modification operations for temporal types. These operations are needed for streaming applications where the observations arrive not necessarily ordered by time. The assumption is that most observations arrive ordered by time and thus, inserting in the middle of a temporal value is an exceptional operation. In this case, we need to push the subsequent instants in the extensible array using a memmove operation in C, which is a costly operation. If on the contrary, the observations would arrive in a random order with respect to time, the extensible array data structure used in MobilityDB is not the right data structure, instead a linked list or a skip list of instants should be used. For example, in MobilityDB skip lists are used for temporal aggregation operations since by definition the temporal values to aggregate come in random order of time.\nMEOS provides the insert, update, and delete operations for modifying the content of an existing sequence or sequence set. As a comparison, PostGIS provides the following update operations for modifying an existing line string: ST_AddPoint, ST_SetPoint, and ST_RemovePoint.\nFirst, we explain the case of inserting or updating an instant or a sequence to an existing sequence, as illustrated next.\nAs shown in the figure, we are adding the temporal sequence (or a temporal instant if n = 1) in the top of the figure to an existing sequence in the bottom of the figure. When vi@ti is the last instant of the sequence, we are adding the new sequence to the end of the existing sequence (this corresponds to an append operation).\nWe start by explaining the insert operation. In this case, it is supposed that ti \u0026lt;= t1 and tn \u0026lt;= ti+1, otherwise an error is thrown. A particular case that must be taken into account is when ti = t1 and/or tn = ti+1. In this case, the semantics depends on the operation performed. In the case of an insert, it is necessary that vi = v1 and vn = vi+1, otherwise an error is thrown. If the constraint is satisfied, the insert does not add the redundant connecting instants. In the case of an update, the values of the connecting instants are updated if they are different. In the general case, if ti \u0026lt; t1 and/or tn \u0026lt; ti+1, then the new instants are added to the sequence.\nOn the other hand, when performing an update operation, the above constraint ti \u0026lt;= t1 and tn \u0026lt;= ti+1 is not required and therefore, the resulting sequence will contain the values in the new sequence, independently of the previous values it had (if any) between the timestamps t1 and tn.\nFinally, when performing a delete operation, it removes the instants between two timestamps tstart and tend passed as parameters, where an additional parameter of the function states whether the values before and after the given timestamps are connected, or on the contrary a temporal gap is added to the sequence, resulting in a sequence set.\nWe now explain the case of inserting or updating an instant or a sequence to an existing sequence set. The case of inserting or updating an existing sequence amounts to the previous case. What remains to be explained is to add a sequence in a temporal gap between two sequences or at the end of a sequence, as illustrated next.\nAs shown in the figure, we are adding the temporal sequence in the top of the figure to a temporal gap in (or at the end of) an existing sequence in the bottom of the figure.\nAs before, in the case of an insert or an update operation, it is supposed that ti \u0026lt;= t1 and ti+1 \u0026gt;= tn, otherwise an error is thrown. When ti = t1 and/or tn = ti+1, we are extending the sequence to the left and/or to the right of the temporal gap and we proceed as explained above. Otherwise, when ti \u0026lt; t1 and tn \u0026lt; ti+1, three different operations can be contemplated, depending on the value of an additional parameter of the insert or update functions. We can either extend the sequence to the left and/or to the right of the gap, or simply add the new sequence in the gap, leaving two gaps to the left and to the right of the new sequence.\nWhen performing a replace operation, the above constraint ti \u0026lt;= t1 and tn \u0026lt;= ti+1 is not required and therefore, the resulting sequence set will contain the values in the new sequence, independently of the previous values it had (if any) between the timestamps t1 and tn. Notice that if t1 \u0026lt;= ti and/or ti+1 \u0026lt;= tn the operation fills (partially or completely) the temporal gap.\nFinally, when performing a delete operation, it removes the instants between two timestamps tstart and tend passed as parameters, where an additional parameter of the function states whether the values before and after the given timestamps are connected, or on the contrary a temporal gap is added to the sequence set.\n"},{"id":14,"href":"/tutorialprograms/meos_hello_world/","title":"My First MEOS Program","parent":"Tutorial Programs","content":"meos_hello_world.c\nThis program creates some temporal values from their WKT format and output them in MF-JSON format.\nThe output of the program is given next.\n-------------------- | Temporal Instant | -------------------- WKT: ---- POINT(1 1)@2000-01-01 MF-JSON: -------- { \u0026#34;type\u0026#34;: \u0026#34;MovingGeomPoint\u0026#34;, \u0026#34;stBoundedBy\u0026#34;: { \u0026#34;bbox\u0026#34;: [ [ 1, 1 ], [ 1, 1 ] ], \u0026#34;period\u0026#34;: { \u0026#34;begin\u0026#34;: \u0026#34;2000-01-01T00:00:00+01\u0026#34;, \u0026#34;end\u0026#34;: \u0026#34;2000-01-01T00:00:00+01\u0026#34; } }, \u0026#34;coordinates\u0026#34;: [ 1, 1 ], \u0026#34;datetimes\u0026#34;: \u0026#34;2000-01-01T00:00:00+01\u0026#34;, \u0026#34;interpolations\u0026#34;: [ \u0026#34;Discrete\u0026#34; ] } ------------------------------------------------- | Temporal Sequence with Discrete Interpolation | ------------------------------------------------- WKT: ---- {POINT(1 1)@2000-01-01, POINT(2 2)@2000-01-02} MF-JSON: -------- { \u0026#34;type\u0026#34;: \u0026#34;MovingGeomPoint\u0026#34;, \u0026#34;stBoundedBy\u0026#34;: { \u0026#34;bbox\u0026#34;: [ [ 1, 1 ], [ 2, 2 ] ], \u0026#34;period\u0026#34;: { \u0026#34;begin\u0026#34;: \u0026#34;2000-01-01T00:00:00+01\u0026#34;, \u0026#34;end\u0026#34;: \u0026#34;2000-01-02T00:00:00+01\u0026#34; } }, \u0026#34;coordinates\u0026#34;: [ [ 1, 1 ], [ 2, 2 ] ], \u0026#34;datetimes\u0026#34;: [ \u0026#34;2000-01-01T00:00:00+01\u0026#34;, \u0026#34;2000-01-02T00:00:00+01\u0026#34; ], \u0026#34;lower_inc\u0026#34;: true, \u0026#34;upper_inc\u0026#34;: true, \u0026#34;interpolations\u0026#34;: [ \u0026#34;Discrete\u0026#34; ] } ----------------------------------------------- | Temporal Sequence with Linear Interpolation | ----------------------------------------------- WKT: ---- [POINT(1 1)@2000-01-01, POINT(2 2)@2000-01-02] MF-JSON: -------- { \u0026#34;type\u0026#34;: \u0026#34;MovingGeomPoint\u0026#34;, \u0026#34;stBoundedBy\u0026#34;: { \u0026#34;bbox\u0026#34;: [ [ 1, 1 ], [ 2, 2 ] ], \u0026#34;period\u0026#34;: { \u0026#34;begin\u0026#34;: \u0026#34;2000-01-01T00:00:00+01\u0026#34;, \u0026#34;end\u0026#34;: \u0026#34;2000-01-02T00:00:00+01\u0026#34; } }, \u0026#34;coordinates\u0026#34;: [ [ 1, 1 ], [ 2, 2 ] ], \u0026#34;datetimes\u0026#34;: [ \u0026#34;2000-01-01T00:00:00+01\u0026#34;, \u0026#34;2000-01-02T00:00:00+01\u0026#34; ], \u0026#34;lower_inc\u0026#34;: true, \u0026#34;upper_inc\u0026#34;: true, \u0026#34;interpolations\u0026#34;: [ \u0026#34;Linear\u0026#34; ] } ------------------------------------------------- | Temporal Sequence with Stepwise Interpolation | ------------------------------------------------- WKT: ---- Interp=Stepwise;[POINT(1 1)@2000-01-01, POINT(2 2)@2000-01-02] MF-JSON: -------- { \u0026#34;type\u0026#34;: \u0026#34;MovingGeomPoint\u0026#34;, \u0026#34;stBoundedBy\u0026#34;: { \u0026#34;bbox\u0026#34;: [ [ 1, 1 ], [ 2, 2 ] ], \u0026#34;period\u0026#34;: { \u0026#34;begin\u0026#34;: \u0026#34;2000-01-01T00:00:00+01\u0026#34;, \u0026#34;end\u0026#34;: \u0026#34;2000-01-02T00:00:00+01\u0026#34; } }, \u0026#34;coordinates\u0026#34;: [ [ 1, 1 ], [ 2, 2 ] ], \u0026#34;datetimes\u0026#34;: [ \u0026#34;2000-01-01T00:00:00+01\u0026#34;, \u0026#34;2000-01-02T00:00:00+01\u0026#34; ], \u0026#34;lower_inc\u0026#34;: true, \u0026#34;upper_inc\u0026#34;: true, \u0026#34;interpolations\u0026#34;: [ \u0026#34;Stepwise\u0026#34; ] } --------------------------------------------------- | Temporal Sequence Set with Linear Interpolation | --------------------------------------------------- WKT: ---- {[POINT(1 1)@2000-01-01, POINT(2 2)@2000-01-02],[POINT(3 3)@2000-01-03, POINT(3 3)@2000-01-04]} MF-JSON: -------- { \u0026#34;type\u0026#34;: \u0026#34;MovingGeomPoint\u0026#34;, \u0026#34;stBoundedBy\u0026#34;: { \u0026#34;bbox\u0026#34;: [ [ 1, 1 ], [ 3, 3 ] ], \u0026#34;period\u0026#34;: { \u0026#34;begin\u0026#34;: \u0026#34;2000-01-01T00:00:00+01\u0026#34;, \u0026#34;end\u0026#34;: \u0026#34;2000-01-04T00:00:00+01\u0026#34; } }, \u0026#34;sequences\u0026#34;: [ { \u0026#34;coordinates\u0026#34;: [ [ 1, 1 ], [ 2, 2 ] ], \u0026#34;datetimes\u0026#34;: [ \u0026#34;2000-01-01T00:00:00+01\u0026#34;, \u0026#34;2000-01-02T00:00:00+01\u0026#34; ], \u0026#34;lower_inc\u0026#34;: true, \u0026#34;upper_inc\u0026#34;: true }, { \u0026#34;coordinates\u0026#34;: [ [ 3, 3 ], [ 3, 3 ] ], \u0026#34;datetimes\u0026#34;: [ \u0026#34;2000-01-03T00:00:00+01\u0026#34;, \u0026#34;2000-01-04T00:00:00+01\u0026#34; ], \u0026#34;lower_inc\u0026#34;: true, \u0026#34;upper_inc\u0026#34;: true } ], \u0026#34;interpolations\u0026#34;: [ \u0026#34;Linear\u0026#34; ] } ----------------------------------------------------- | Temporal Sequence Set with Stepwise Interpolation | ----------------------------------------------------- WKT: ---- Interp=Stepwise;{[POINT(1 1)@2000-01-01, POINT(2 2)@2000-01-02],[POINT(3 3)@2000-01-03, POINT(3 3)@2000-01-04]} MF-JSON: -------- { \u0026#34;type\u0026#34;: \u0026#34;MovingGeomPoint\u0026#34;, \u0026#34;stBoundedBy\u0026#34;: { \u0026#34;bbox\u0026#34;: [ [ 1, 1 ], [ 3, 3 ] ], \u0026#34;period\u0026#34;: { \u0026#34;begin\u0026#34;: \u0026#34;2000-01-01T00:00:00+01\u0026#34;, \u0026#34;end\u0026#34;: \u0026#34;2000-01-04T00:00:00+01\u0026#34; } }, \u0026#34;sequences\u0026#34;: [ { \u0026#34;coordinates\u0026#34;: [ [ 1, 1 ], [ 2, 2 ] ], \u0026#34;datetimes\u0026#34;: [ \u0026#34;2000-01-01T00:00:00+01\u0026#34;, \u0026#34;2000-01-02T00:00:00+01\u0026#34; ], \u0026#34;lower_inc\u0026#34;: true, \u0026#34;upper_inc\u0026#34;: true }, { \u0026#34;coordinates\u0026#34;: [ [ 3, 3 ], [ 3, 3 ] ], \u0026#34;datetimes\u0026#34;: [ \u0026#34;2000-01-03T00:00:00+01\u0026#34;, \u0026#34;2000-01-04T00:00:00+01\u0026#34; ], \u0026#34;lower_inc\u0026#34;: true, \u0026#34;upper_inc\u0026#34;: true } ], \u0026#34;interpolations\u0026#34;: [ \u0026#34;Stepwise\u0026#34; ] } The above ouput uses the pretty-printing options provided by the json-c library to facilite human reading. By changing the corresponding flag in the program it is possible to obtain a more compact machine-processable representation.\nA similar result can be obtained in MobilityDB with the following SQL query.\nWITH temp(k, t) AS ( SELECT 1, tgeompoint \u0026#39;POINT(1 1)@2000-01-01\u0026#39; UNION SELECT 2, tgeompoint \u0026#39;{POINT(1 1)@2000-01-01, POINT(2 2)@2000-01-02}\u0026#39; UNION SELECT 3, tgeompoint \u0026#39;[POINT(1 1)@2000-01-01, POINT(2 2)@2000-01-02]\u0026#39; UNION SELECT 4, tgeompoint \u0026#39;{[POINT(1 1)@2000-01-01, POINT(2 2)@2000-01-02], [POINT(3 3)@2000-01-03, POINT(3 3)@2000-01-04]}\u0026#39; ) SELECT asEWKT(t), asMFJSON(t,1) FROM temp ORDER BY k; "},{"id":15,"href":"/documentation/normalization/","title":"Normalization","parent":"Documentation","content":"MEOS normalizes sequence or sequence set values that are continuous (that is, when the interpolation is linear or stepwise). For this, consecutive instant values are merged when possible. Recall that two consecutive instant values v1@t1 and v2@t2 define a linear function that states the evolution of the base value between the two timestamps. In this regard, the stepwise interpolation is just a particular case of the linear interpolation when the linear function is constant.\nWe start by analyzing the case of sequence values. Given three consecutive instant values, the middle value can be deleted if the linear functions defining the evolution of values are the same. This is illustrated in the figure below for linear and stepwise interpolation, where the sequence values in the left are replaced through normalization by the values on the right.\nAs can be seen, the sequences at the left convey the same information as the sequences at the right. Therefore, normalization ensures that we have a unique representation for equivalent sequences. Examples of normalization for sequence values are shown below\ntint \u0026#39;[1@2001-01-01, 2@2001-01-03, 2@2001-01-04, 2@2001-01-05)\u0026#39; -\u0026gt; [1@2001-01-01, 2@2001-01-03, 2@2001-01-05) tgeompoint \u0026#39;[Point(1 1)@2001-01-01 08:00:00, Point(1 1)@2001-01-01 08:05:00, Point(1 1)@2001-01-01 08:10:00)\u0026#39; -\u0026gt; [Point(1 1)@2001-01-01 08:00:00, Point(1 1)@2001-01-01 08:10:00) tfloat \u0026#39;[1@2001-01-01, 2@2001-01-03, 3@2001-01-05]\u0026#39; -\u0026gt; [1@2001-01-01, 3@2001-01-05] tgeompoint \u0026#39;[Point(1 1)@2001-01-01 08:00:00, Point(2 2)@2001-01-01 08:05:00, Point(3 3)@2001-01-01 08:10:00]\u0026#39; -\u0026gt; [Point(1 1)@2001-01-01 08:00:00, Point(3 3)@2001-01-01 08:10:00] In the case of sequence set values, two composing sequences are merged whenever possible. This is the case when the instant to be removed connects two consecutive sequences. This is illustrated below, where we only consider the case where the first sequence is right exclusive and the second one is left inclusive.\nExamples of normalization for sequence set values are shown below\ntgeompoint \u0026#39;{[Point(0 0)@2001-01-01 08:00:00, Point(1 1)@2001-01-01 08:05:00, Point(1 1)@2001-01-01 08:10:00), [Point(1 1)@2001-01-01 08:10:00, Point(1 1)@2001-01-01 08:15:00)}\u0026#39;) -\u0026gt; {[[Point(0 0)@2001-01-01 08:00:00, Point(1 1)@2001-01-01 08:05:00, Point(1 1)@2001-01-01 08:15:00)} tfloat \u0026#39;{[1@2001-01-01, 2@2001-01-03), [2@2001-01-03, 3@2001-01-05]}\u0026#39; -\u0026gt; \u0026#39;{[1@2001-01-01, 3@2001-01-05]}\u0026#39; tint \u0026#39;{[1@2001-01-01, 1@2001-01-03), [2@2001-01-03, 2@2001-01-05)}\u0026#39; -\u0026gt; \u0026#39;{[1@2001-01-01, 2@2001-01-03, 2@2001-01-05)}\u0026#39; tgeompoint \u0026#39;{[Point(1 1)@2001-01-01 08:00:00,Point(2 2)@2001-01-01 08:05:00), [Point(2 2)@2001-01-01 08:05:00, Point(3 3)@2001-01-01 08:10:00]}\u0026#39;) -\u0026gt; {[Point(1 1)@2001-01-01 08:00:00, Point(3 3)@2001-01-01 08:10:00]} tgeompoint \u0026#39;{[Point(1 1)@2001-01-01 08:00:00,Point(3 3)@2001-01-01 08:10:00), [Point(3 3)@2001-01-01 08:10:00]}\u0026#39; -\u0026gt; {[Point(1 1)@2001-01-01 08:00:00, Point(3 3)@2001-01-01 08:10:00]} The normalization process is performed by the constructors of the TSequence and TSequenceSet. Therefore, this happens both at the time mobility data is input and when computing the result of any operation. Normalization thus performs lossless compression that can achieve up to 400% compression rate when real-world mobility data is input.\n"},{"id":16,"href":"/tutorialprograms/meos_read_ais/","title":"Reading from File","parent":"Tutorial Programs","content":"meos_read_ais.c\nThis program reads AIS data from a CSV file and outputs a few of these records converted into temporal values.\nThe output of the program is given next.\nMMSI: 566948000, Location: POINT(4.62 55.57)@2021-01-08 01:10:46+01 SOG : 0.5@2021-01-08 01:10:46+01 MMSI: 566948000, Location: POINT(4.62 55.57)@2021-01-08 01:21:25+01 SOG : 0.1@2021-01-08 01:21:25+01 MMSI: 219001559, Location: POINT(9.98 57.59)@2021-01-08 01:33:48+01 SOG : 0.1@2021-01-08 01:33:48+01 ... MMSI: 219001559, Location: POINT(9.98 57.59)@2021-01-09 00:43:35+01 SOG : 0@2021-01-09 00:43:35+01 MMSI: 566948000, Location: POINT(4.49 55.64)@2021-01-09 00:52:34+01 SOG : 0.3@2021-01-09 00:52:34+01 156837 records read. 0 incomplete records ignored. A similar result can be obtained in MobilityDB with the following SQL commands.\nSET timezone = \u0026#39;UTC\u0026#39;; CREATE TABLE public.AISInput(t TimestampTz, MMSI integer, latitude float, longitude float, sog float); COPY AISInput(t, MMSI, latitude, longitude, sog) FROM \u0026#39;/home/MobilityDB/meos/examples/aisinput.csv\u0026#39; CSV HEADER; SELECT MMSI, asText(tgeompoint_inst(ST_Point(longitude, latitude), t)), tfloat_inst(sog, t) FROM AISInput; "},{"id":17,"href":"/tutorialprograms/meos_simplify_berlinmod/","title":"Simplifying Trips","parent":"Tutorial Programs","content":"meos_simplify_berlinmod.c\nThis program reads a CSV file containing synthetic trip data in Brussels generated by the MobilityDB-BerlinMOD generator, simplifies the trips using both Douglas-Peucker (DP) and Synchronized Euclidean Distance (SED, also known as Top-Down Time Ratio simplification), and outputs for each trip the initial number of instants and the number of instants of the two simplified trips.\nThe output of the program is given next.\n55 records read. 0 incomplete records ignored. Vehicle: 1, Date: 2020-06-01, Seq: 1, No. of instants: 2472, No. of instants DP: 163, No. of instants SED: 1149 Vehicle: 1, Date: 2020-06-01, Seq: 2, No. of instants: 2420, No. of instants DP: 138, No. of instants SED: 1103 Vehicle: 1, Date: 2020-06-02, Seq: 1, No. of instants: 2481, No. of instants DP: 163, No. of instants SED: 1147 ... Vehicle: 5, Date: 2020-06-04, Seq: 3, No. of instants: 99, No. of instants DP: 17, No. of instants SED: 56 Vehicle: 5, Date: 2020-06-04, Seq: 4, No. of instants: 116, No. of instants DP: 18, No. of instants SED: 58 A similar result can be obtained in MobilityDB with the following SQL query, assuming that the CSV file has been previously loaded into the trips table.\nSELECT vehid, day, seqno, numInstants(trip), numInstants(simplify(trip, 2)) AS numInstantsDP, numInstants(simplify(trip, 2, true)) AS numInstantsSED FROM trips ORDER BY vehid, day, seqno; "},{"id":18,"href":"/tutorialprograms/meos_store_ais/","title":"Storing in MobilityDB","parent":"Tutorial Programs","content":"meos_store_ais.c\nThis program reads AIS data from a CSV file, converts them into temporal values, and stores them in MobilityDB. The program uses the libpq library to connect to PostgreSQL.\nThe output of the program is given next.\nCreating the table in the database NOTICE: table \u0026#34;aisinstants\u0026#34; does not exist, skipping Start processing the file 156837 records read. 0 incomplete records ignored. Query \u0026#39;SELECT COUNT(*) FROM public.AISInstants\u0026#39; returned 156837 A similar result can be obtained in MobilityDB with the following SQL query, assuming that the CSV file has been previously loaded into the AISInput table.\nCREATE TABLE public.AISInstants(MMSI integer, location public.tgeogpoint, SOG public.tfloat); INSERT INTO AISInstants(MMSI, location, SOG) SELECT MMSI, tgeogpoint_inst(ST_SetSRID(ST_Point(longitude, latitude), 4326), t), tfloat_inst(sog, t) FROM AISInput; SELECT COUNT(*) FROM AISInput; "},{"id":19,"href":"/tutorialprograms/meos_stream_ais/","title":"Stream Processing","parent":"Tutorial Programs","content":"meos_stream_ais.c\nA simple program that reads AIS data from a CSV file, accumulates the observations in main memory and send the temporal values to a MobilityDB database when they reach a given number of instants in order to free the memory and ingest the newest observations. The program uses the libpq library to connect to PostgreSQL.\nThe output of the program is given next.\nCreating the table AISTrips in the database Accumulating 1000 instants before sending them to the database (one marker every database update) ********************************************************************************************************** 156837 records read. 0 incomplete records ignored. Result of the query \u0026#39;SELECT MMSI, public.numInstants(trip) FROM public.AISTrips;\u0026#39; mmsi | numinstants -----------+------------- 257136000 | 20978 219001559 | 35781 566948000 | 23946 219027804 | 16417 265513270 | 7707 "},{"id":20,"href":"/tutorialprograms/meos_tile_berlinmod/","title":"Tiling Trips","parent":"Tutorial Programs","content":"meos_tile_berlinmod.c\nThis program reads a CSV file containing synthetic trip data in Brussels generated by the MobilityDB-BerlinMOD generator, splits the trips and the speed of these trips by tiles, and computes aggregate values of the count, duration, and distance of the tiles.\nThe output of the program is given next.\nProcessing records ******************************************************* 55 records read. 0 incomplete records ignored. ------------- Trip tiles ------------- Tile: (0,0), Box: SRID=3857;STBOX X(((470000,6575000),(475000,6580000))), Count: 8, Duration: 00:19:46.615846, Distance: 10.786511 Tile: (0,4), Box: SRID=3857;STBOX X(((490000,6575000),(495000,6580000))), Count: 4, Duration: 00:04:04.031572, Distance: 1.604871 Tile: (0,6), Box: SRID=3857;STBOX X(((470000,6580000),(475000,6585000))), Count: 8, Duration: 00:22:18.779158, Distance: 16.538983 Tile: (1,0), Box: SRID=3857;STBOX X(((475000,6580000),(480000,6585000))), Count: 8, Duration: 01:31:49.677269, Distance: 53.885458 Tile: (1,1), Box: SRID=3857;STBOX X(((480000,6580000),(485000,6585000))), Count: 8, Duration: 01:49:33.714171, Distance: 37.778044 Tile: (1,2), Box: SRID=3857;STBOX X(((485000,6580000),(490000,6585000))), Count: 8, Duration: 00:45:04.538618, Distance: 22.131790 Tile: (1,3), Box: SRID=3857;STBOX X(((490000,6580000),(495000,6585000))), Count: 16, Duration: 01:20:51.078422, Distance: 32.945149 Tile: (1,4), Box: SRID=3857;STBOX X(((495000,6580000),(500000,6585000))), Count: 8, Duration: 00:27:20.533366, Distance: 32.372265 Tile: (1,6), Box: SRID=3857;STBOX X(((475000,6585000),(480000,6590000))), Count: 8, Duration: 01:04:37.100221, Distance: 21.461376 Tile: (2,0), Box: SRID=3857;STBOX X(((480000,6585000),(485000,6590000))), Count: 8, Duration: 00:50:10.544733, Distance: 25.760025 Tile: (2,1), Box: SRID=3857;STBOX X(((485000,6585000),(490000,6590000))), Count: 8, Duration: 01:10:56.856836, Distance: 38.339253 Tile: (2,2), Box: SRID=3857;STBOX X(((490000,6585000),(495000,6590000))), Count: 8, Duration: 00:26:10.436406, Distance: 14.058617 Tile: (2,3), Box: SRID=3857;STBOX X(((495000,6585000),(500000,6590000))), Count: 8, Duration: 00:38:18.048761, Distance: 43.095820 Tile: (2,6), Box: SRID=3857;STBOX X(((480000,6590000),(485000,6595000))), Count: 8, Duration: 01:23:20.018189, Distance: 39.784050 Tile: (3,0), Box: SRID=3857;STBOX X(((485000,6590000),(490000,6595000))), Count: 8, Duration: 01:11:47.367447, Distance: 48.640160 Tile: (3,1), Box: SRID=3857;STBOX X(((490000,6590000),(495000,6595000))), Count: 12, Duration: 01:02:57.574739, Distance: 33.033053 Tile: (3,2), Box: SRID=3857;STBOX X(((495000,6590000),(500000,6595000))), Count: 14, Duration: 01:07:06.635146, Distance: 54.751272 Tile: (3,5), Box: SRID=3857;STBOX X(((480000,6595000),(485000,6600000))), Count: 18, Duration: 02:56:21.041016, Distance: 90.521896 Tile: (3,6), Box: SRID=3857;STBOX X(((485000,6595000),(490000,6600000))), Count: 8, Duration: 00:34:53.294617, Distance: 21.691950 Tile: (4,0), Box: SRID=3857;STBOX X(((490000,6595000),(495000,6600000))), Count: 8, Duration: 00:39:38.783947, Distance: 28.283381 Tile: (4,1), Box: SRID=3857;STBOX X(((495000,6595000),(500000,6600000))), Count: 23, Duration: 01:49:57.921917, Distance: 67.974290 Tile: (4,3), Box: SRID=3857;STBOX X(((475000,6600000),(480000,6605000))), Count: 10, Duration: 00:55:28.209348, Distance: 13.240459 Tile: (4,4), Box: SRID=3857;STBOX X(((480000,6600000),(485000,6605000))), Count: 10, Duration: 00:39:04.266773, Distance: 17.265266 Tile: (4,5), Box: SRID=3857;STBOX X(((485000,6600000),(490000,6605000))), Count: 8, Duration: 00:47:58.754216, Distance: 36.384378 Tile: (4,6), Box: SRID=3857;STBOX X(((490000,6600000),(495000,6605000))), Count: 16, Duration: 02:33:50.892969, Distance: 71.120467 Tile: (5,0), Box: SRID=3857;STBOX X(((495000,6600000),(500000,6605000))), Count: 8, Duration: 00:44:19.986058, Distance: 27.253547 Tile: (5,5), Box: SRID=3857;STBOX X(((490000,6605000),(495000,6610000))), Count: 22, Duration: 00:50:45.16079, Distance: 34.812390 Tile: (5,6), Box: SRID=3857;STBOX X(((495000,6605000),(500000,6610000))), Count: 2, Duration: 00:01:28.891909, Distance: 0.887142 ------------- Speed tiles ------------- Tile: (0,0), Span: [0, 10), Period: [2020-06-01 00:00:00+02, 2020-06-02 00:00:00+02), Count: 15, Duration: 04:22:34.710424 Tile: (0,1), Span: [10, 20), Period: [2020-06-01 00:00:00+02, 2020-06-02 00:00:00+02), Count: 15, Duration: 02:41:13.617439 Tile: (0,2), Span: [20, 30), Period: [2020-06-01 00:00:00+02, 2020-06-02 00:00:00+02), Count: 8, Duration: 00:16:14.737605 Tile: (0,3), Span: [30, 40), Period: [2020-06-01 00:00:00+02, 2020-06-02 00:00:00+02), Count: 5, Duration: 00:10:19.359894 Tile: (1,0), Span: [0, 10), Period: [2020-06-02 00:00:00+02, 2020-06-03 00:00:00+02), Count: 12, Duration: 03:41:45.691217 Tile: (1,1), Span: [10, 20), Period: [2020-06-02 00:00:00+02, 2020-06-03 00:00:00+02), Count: 12, Duration: 02:36:48.00074 Tile: (1,2), Span: [20, 30), Period: [2020-06-02 00:00:00+02, 2020-06-03 00:00:00+02), Count: 8, Duration: 00:16:31.4621 Tile: (1,3), Span: [30, 40), Period: [2020-06-02 00:00:00+02, 2020-06-03 00:00:00+02), Count: 4, Duration: 00:10:18.383576 Tile: (2,0), Span: [0, 10), Period: [2020-06-03 00:00:00+02, 2020-06-04 00:00:00+02), Count: 14, Duration: 03:50:32.840146 Tile: (2,1), Span: [10, 20), Period: [2020-06-03 00:00:00+02, 2020-06-04 00:00:00+02), Count: 14, Duration: 02:40:39.675611 Tile: (2,2), Span: [20, 30), Period: [2020-06-03 00:00:00+02, 2020-06-04 00:00:00+02), Count: 9, Duration: 00:16:10.08588 Tile: (2,3), Span: [30, 40), Period: [2020-06-03 00:00:00+02, 2020-06-04 00:00:00+02), Count: 6, Duration: 00:10:20.669972 Tile: (3,0), Span: [0, 10), Period: [2020-06-04 00:00:00+02, 2020-06-05 00:00:00+02), Count: 14, Duration: 03:51:02.500427 Tile: (3,1), Span: [10, 20), Period: [2020-06-04 00:00:00+02, 2020-06-05 00:00:00+02), Count: 14, Duration: 02:39:02.330412 Tile: (3,2), Span: [20, 30), Period: [2020-06-04 00:00:00+02, 2020-06-05 00:00:00+02), Count: 7, Duration: 00:16:10.821293 Tile: (3,3), Span: [30, 40), Period: [2020-06-04 00:00:00+02, 2020-06-05 00:00:00+02), Count: 5, Duration: 00:10:15.867724 A similar result can be obtained in MobilityDB with the following SQL queries, assuming that the CSV file has been previously loaded into the trips table.\nWITH temp1(extent) AS ( SELECT extent(trip) FROM trips ), temp2 AS ( SELECT (g).index, (g).box FROM (SELECT multidimGrid(extent, 5e3) AS g FROM temp1 ) t ) SELECT index, box, SUM(1) AS count, SUM(duration(atSTbox(trip, box))) AS duration, SUM(length(atSTbox(trip, box))) / 1e3 AS distance FROM trips, temp2 WHERE atSTbox(trip, box) IS NOT NULL GROUP BY index, box ORDER BY index; WITH temp1(extent) AS ( SELECT extent(speed(trip)) FROM trips ), temp2 AS ( SELECT (g).index, (g).box FROM (SELECT multidimGrid(extent, 10, \u0026#39;1 day\u0026#39;, 0, \u0026#39;2020-06-01\u0026#39;) AS g FROM temp1 ) t ) SELECT index, box::floatspan AS span, box::period AS period, SUM(1) AS count, SUM(duration(atTbox(speed(trip), box))) AS duration FROM trips, temp2 WHERE atTbox(speed(trip), box) IS NOT NULL GROUP BY index, box ORDER BY index; "},{"id":21,"href":"/documentation/developer/","title":"Developer's Documentation","parent":"Documentation","content":"The developer\u0026rsquo;s documentation is available at https://estebanzimanyi.github.io/MobilityDB/index.html\nAlternatively, you can generate the English developer\u0026rsquo;s documentation in HTML format from the source:\ngit clone --branch develop https://github.com/MobilityDB/MobilityDB MobilityDB mkdir MobilityDB/build cd MobilityDB/build cmake -DMEOS=on -DDOC_DEV=on .. make -j make doc_dev The resulting HTML documentation will be generated in the doxygen directory of the build directory.\n"},{"id":22,"href":"/project/","title":"Project","parent":"MEOS","content":"MEOS (Mobility Engine, Open Source) is a C library for manipulating temporal and spatio-temporal data. It is based on MobilityDB\u0026rsquo;s data types and functions.\nMobilityDB extends the ISO 19141:2008 standard (Geographic information — Schema for moving features) for representing the change of non-spatial attributes of features, which is not covered by the standard. It also takes into account the fact that when collecting mobility data it is necessary to represent “temporal gaps”, that is, for some period of time, no observations were collected, for instance, due to GPS signal loss.\nMEOS is heavily inspired by a similar library called GEOS (Geometry Engine, Open Source) — hence the name. A first version of the MEOS library written in C++ has been proposed by Krishna Chaitanya Bommakanti. However, due to the fact that MEOS codebase is actually a subset of MobilityDB codebase, which is almost entire written in C, this version of the library allows us to evolve both programming environments simultaneously.\nMEOS aims to be the base on which more libraries can be built. The following projects are built on top of MEOS:\nPyMEOS is a python bindings to MEOS using (CFFI)[https://cffi.readthedocs.io/en/latest/] MobilityDB-python - The python driver for MobilityDB. "},{"id":23,"href":"/project/licence/","title":"Licence","parent":"Project","content":"MEOS is open source software available under the terms of the PostgreSQL license\n"},{"id":24,"href":"/","title":"MEOS","parent":"","content":"MEOS (Mobility Engine, Open Source) is a C library and its associated API for manipulating temporal and spatiotemporal data. It is the core component of MobilityDB, an open source geospatial trajectory data management \u0026amp; analysis platform built on top of PostgreSQL and PostGIS.\nMEOS extends the ISO 19141:2008 standard (Geographic information — Schema for moving features) for representing the change of non-spatial attributes of features. It also takes into account the fact that when collecting mobility data it is necessary to represent “temporal gaps”, that is, when for some period of time no observations were collected due, for instance, to signal loss.\nMEOS is heavily inspired by a similar library called GEOS (Geometry Engine, Open Source) — hence the name. A first version of the MEOS library written in C++ has been proposed by Krishna Chaitanya Bommakanti. However, due to the fact that MEOS codebase is actually a subset of MobilityDB codebase, which is written in C and in SQL, the current version of the library allows us to evolve both programming environments simultaneously.\nMEOS aims to be the base library on which other projects can be built. For example, the following projects are built on top of MEOS:\nPyMEOS is a Python binding to MEOS using CFFI MobilityDB is a PostgreSQL extension that enables storing and manipulating the temporal types provided by MEOS. Other projects can built on top of MEOS, for example, Java or C# drivers for MEOS or implementing MEOS on other DBMSs such as MySQL.\n"},{"id":25,"href":"/tags/","title":"Tags","parent":"MEOS","content":""}]